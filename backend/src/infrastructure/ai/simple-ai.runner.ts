import * as path from 'path';
import { AiRunner, AiRunnerResult } from '../../application/ports/ai-runner';
import { COVERAGE_FILE_FORMAT_EXAMPLE, COVERAGE_FILE_SUMMARY_NAME, CUSTOM_AGENT_INSTRUCTIONS_FILE_PATH, execToString, mdTemplate, safeStatSync } from '@utils';
import { execa } from 'execa';
import { readFileSync } from 'fs';

export class SimpleAiRunner implements AiRunner {

  model: string;

  constructor() {
    //OpenAIConfig.initialize();
    this.model = 'gpt-5.1-codex'
  }

  private getNewPrBranchName(file: string): string {
    const branchFriendlyFileName = path.basename(file, '.ts').replace(/\W+/g, '-').toLowerCase();
    const branchFriendlyDateName = new Date().toISOString().replace(/[^\w-]/g, '-');
    return `tci--${branchFriendlyFileName}--${branchFriendlyDateName}`;
  }

  private getNewPrTitle(file: string): string {
    return `Improve test coverage for ${file}`;
  }

  private getNewPrBody(): string {
    return 'Automatically generated by ts-coverage-improver/codex'
  }

  private generatePrompt(filePath: string): string {
    const pathToPrompt =  path.resolve(__dirname, 'AGENTS.ts-coverage-improver.md');
    const stat = safeStatSync(pathToPrompt);
    if (!stat?.isFile()) {
      console.error(`Agent prompt not found at ${pathToPrompt}`);
      throw new Error(`Agent prompt not found`);
    }
    const promptTemplate = readFileSync(pathToPrompt, 'utf-8');
    const prompt = mdTemplate(promptTemplate, {
      example: JSON.stringify(COVERAGE_FILE_FORMAT_EXAMPLE, null, 2),
      coverageFileSummaryName: COVERAGE_FILE_SUMMARY_NAME,
      targetFile: filePath,
    });
    return prompt;
  }

  getNewPrInfo(file: string) {
    return {
      branch: this.getNewPrBranchName(file),
      title: this.getNewPrTitle(file),
      body: this.getNewPrBody(),
    }
  }


  async run(params: {
    repoPath: string,
    filePath: string,
    owner: string,
    repo: string
  }): Promise<AiRunnerResult> {
    const { repoPath, filePath, owner, repo } = params;
    const prInfo = this.getNewPrInfo(filePath);
    const { branch: prBranch, title: prTitle, body: prBody } = prInfo;

    try {
      console.info("Preparing to run")
      const prompt = this.generatePrompt(filePath);
      console.info("Generated prompt: ", prompt);
      const baseBranch = execToString("git rev-parse --abbrev-ref HEAD", repoPath);
      await execa('git', ['checkout', '-b', prBranch], { cwd: repoPath });
      const newBranch = execToString("git rev-parse --abbrev-ref HEAD", repoPath);
      console.info(`Created and switched to new branch ${newBranch}`);
      console.info("Running codex command")
      await execa('codex', ['--cd', repoPath, 'exec', '--yolo', prompt], {
        cwd: repoPath,
        stdio: 'inherit',
      });
      console.info("finished running")
      await execa('git', ['add', '-A'], { cwd: repoPath });
      await execa('git', ['commit', '-m', `ts-coverage-improver: Improve test coverage for ${filePath}`], { cwd: repoPath });
      await execa('git', ['push', '-u', 'origin', prBranch], { cwd: repoPath });
      await execa('gh', ['pr', 'create', '--title', prTitle, '--body', prBody, '--head', prBranch, '--base', baseBranch], { cwd: repoPath });
      const prsList = execToString(`gh pr list --head "${prBranch}" --json url,headRefName --limit 1`, repoPath);
      const prsListJson = JSON.parse(prsList) as [{ url: string; headRefName: string }];
      if (!prsListJson.length || prsListJson[0].headRefName !== prBranch) {
        console.error("PR not found from: ", prsListJson);
        throw new Error("PR not found");
      }
      const prUrl = prsListJson[0].url;
      console.info("PR created at ", prUrl);
      await execa('git', ['checkout', baseBranch], { cwd: repoPath });
      return { success: true, output: prUrl };
    } catch (err: any) {
      console.error("Error", err);
      return {
        success: false,
        output: 'Job failed'
      };
    }
  }
}
